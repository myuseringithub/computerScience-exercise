/**********************************************************************
 Java CUP specification for a parser for C-- programs.
 **********************************************************************/

import java_cup.runtime.*;
import java.util.*;

/*
 * The code below redefines method syntax_error to give better error messages
 * than just "Syntax error".
 */
parser code {:
    public void syntax_error(Symbol currToken) {
        if (currToken.value == null) {
            ErrMsg.fatal(0,0, "Syntax error at end of file");
        }
        else {
            ErrMsg.fatal(((TokenVal)currToken.value).linenum,
                        ((TokenVal)currToken.value).charnum,
                        "Syntax error");
        }
        System.exit(-1);
    }
:};

/* Terminals (tokens returned by the scanner). */
terminal                INT;
terminal                BOOL;
terminal                VOID;
terminal                TRUE;
terminal                FALSE;
terminal                STRUCT;
terminal                CIN;
terminal                COUT;
terminal                IF;
terminal                ELSE;
terminal                WHILE;
terminal		        REPEAT;
terminal                RETURN;
terminal IdTokenVal     ID;
terminal IntLitTokenVal INTLITERAL;
terminal StrLitTokenVal STRINGLITERAL;
terminal                LCURLY;
terminal                RCURLY;
terminal                LPAREN;
terminal                RPAREN;
terminal                SEMICOLON;
terminal                COMMA;
terminal                DOT;
terminal                WRITE;
terminal                READ;
terminal                PLUSPLUS;
terminal                MINUSMINUS;
terminal                PLUS;
terminal                MINUS;
terminal                TIMES;
terminal                DIVIDE;
terminal                NOT;
terminal                AND;
terminal                OR;
terminal                EQUALS;
terminal                NOTEQUALS;
terminal                LESS;
terminal                GREATER;
terminal                LESSEQ;
terminal                GREATEREQ;
terminal                ASSIGN;
terminal                UMINUS; // dummy terminal for precedence setting

/* Non-terminals
 *
 * TODO: You will need to add more non-terminals to this list as you add 
 *       productions to the grammar below.
 */
non terminal ProgramNode      program;
non terminal LinkedList       list_decl;
non terminal DeclNode         decl;
non terminal                  list_varDecl;
non terminal VarDeclNode      varDecl;
non terminal                  fnDecl;
non terminal StructDeclNode   structDecl;
non terminal                  structBody;
non terminal                  formals;
non terminal                  formalsList;
non terminal                  formalDecl;
non terminal                  fnBody;
non terminal                  stmtList;
non terminal                  stmt;
non terminal                  assignExp;
non terminal                  exp;
non terminal                  term;
non terminal                  fncall;
non terminal                  actualList;
non terminal TypeNode         type;
non terminal                  loc;
non terminal IdNode           id;


/* Precedences & Associativity */
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence nonassoc LESS, GREATER, LESSEQ, GREATEREQ, EQUALS, NOTEQUALS;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left UMINUS, NOT;

start with program;

/* The grammar with actions */
program                                                                                         ::= 
            list_decl:x                                                                         {:            
                RESULT = new ProgramNode(new DeclListNode(x));
                                                                                                    :};
list_decl                                                                                       ::= 
            list_decl:x1 decl:x2                                                                {:       
                x1.addLast(x2);
                RESULT = x1;
                                                                                                    :}
|           /* epsilon */                                                                         {: 
                RESULT = new LinkedList<DeclNode>();
                                                                                                    :};
decl                                                                                             ::= 
            varDecl:x                                                                            {: 
                RESULT = new DeclNode();
                                                                                                     :}
|           fnDecl:x                                                                               {: 
                RESULT = new DeclNode();
                                                                                                     :}
|           structDecl:x                                                                           {: 
                 // struct definitions only at top level
                 RESULT = new DeclNode();
                                                                                                     :};

list_varDecl                                                                                    ::= 
            list_varDecl varDecl                                                             {: 
                                                                                    
                                                                                                :}
|           /* epsilon */                                                                  {: 
                                                                                                    
                                                                                                    :};

varDecl                                                                                          ::= 
            type:t id:i SEMICOLON                                                                {:
                RESULT = new VarDeclNode(t, i, VarDeclNode.NOT_STRUCT);         
                                                                                      :}
|           STRUCT id id SEMICOLON                                                                {:
                RESULT = new VarDeclNode();
                                                                                      :};

fnDecl                                                                                          ::= 
            type id formals fnBody                                                {:

                                                                                :};

structDecl                                                                                   ::= 
            STRUCT id:i LCURLY structBody:s RCURLY SEMICOLON                                      {:
                RESULT = new StructDeclNode();
                                                                                    :};
structBody                                                                                       ::= 
            structBody varDecl                                                                       {:
                
                                                                                    :}
|           varDecl:v                                                                            {:
                RESULT = v;
                                                                                    :};

formals                                                                                          ::= 
            LPAREN RPAREN                                                                            {:

                                                                                                :}
|           LPAREN formalsList RPAREN                                                                {:
                
                                                                                                :};

formalsList                                                                                      ::=
            formalDecl                                                                               {:

                                                                                :}
|           formalDecl COMMA formalsList                                                          {:
                
                                                                                                :};

formalDecl                                                                                       ::= 
            type id                                                                                                    {:
                    // note: no struct parameters
                                                                                    :};

fnBody                                                                                           ::= 
            LCURLY list_varDecl stmtList RCURLY                                                               {:
                                                                                    
                                                                                    :};

stmtList                                                                                         ::= 
            stmtList stmt                                                                            {:
                                                                                    
                                                                                                  :}
|           /* epsilon */                                                                            {:
                                                                                                    
                                                                                                    :};

stmt                                                                                              ::= 
            assignExp SEMICOLON                                                                         {:
                                                                                            
                                                                                            :}
|           loc PLUSPLUS SEMICOLON                                                                 {:
                                                                                                            
                                                                                                            :}
|           loc MINUSMINUS SEMICOLON                                                                 {:
                                                                                                            
                                                                                                            :}
|           CIN READ loc SEMICOLON                                                                   {:
                                                                                                            
                                                                                                            :}
|           COUT WRITE exp SEMICOLON                                                                 {:        
                                                                                                            
                                                                                                            :}
|           IF LPAREN exp RPAREN LCURLY list_varDecl stmtList RCURLY                                 {:
                                                                                                            
                                                                                                            :}
|           IF LPAREN exp RPAREN LCURLY list_varDecl stmtList RCURLY ELSE LCURLY list_varDecl stmtList RCURLY                                                                                                {:
                                                                                                            
                                                                                                            :}
|           WHILE LPAREN exp RPAREN LCURLY list_varDecl stmtList RCURLY                                                   {:
                                                                                                            
                                                                                                            :}
|           REPEAT LPAREN exp RPAREN LCURLY list_varDecl stmtList RCURLY                                                  {:
                                                                                                            
                                                                                                            :}
|           RETURN exp SEMICOLON                                                                  {:
                                                                                                            
                                                                                                            :}
|           RETURN SEMICOLON                                                                          {:
                                                                                                            
                                                                                                            :}
|           fncall SEMICOLON                                                                          {:
                                                                                                            
                                                                                                            :};

assignExp                                                                                            ::= 
            loc ASSIGN exp                                                                             {:

                                                                                                     :};                                 

exp                                                                                                   ::= 
            assignExp                                                                                   {:

                                                                                                        :}
|           exp PLUS exp                                                                             {:
                
                                                                                                    :}
|           exp MINUS exp                                                                                {:
                
                                                                                                    :}
|           exp TIMES exp                                                                                {:
                
                                                                                                    :}
|           exp DIVIDE exp                                                                               {:
                
                                                                                                    :}
|           NOT exp                                                                              {:
                
                                                                                                    :}
|           exp AND exp                                                                              {:
                
                                                                                                    :}
|           exp OR exp                                                                               {:
                
                                                                                                    :}
|           exp EQUALS exp                                                                               {:
                
                                                                                                    :}
|           exp NOTEQUALS exp                                                                                {:
                
                                                                                                    :}
|           exp LESS exp                                                                             {:
                
                                                                                                    :}
|           exp GREATER exp                                                                              {:
                
                                                                                                    :}
|           exp LESSEQ exp                                                                               {:
                
                                                                                                    :}
|           exp GREATEREQ exp                                                                                {:
                
                                                                                                    :}
|           MINUS term                                                                               {:
                
                                                                                                    :}
            %prec UMINUS
|           term                                                                                     {: 
                
                                                                                                    :};


term                                                                                                     ::= 
            loc                                                                                          {:

                                                                                                        :}
|           INTLITERAL                                                                                  {:
                
                                                                                                :}
|           STRINGLITERAL                                                                                    {:
                
                                                                                                :}
|           TRUE                                                                                  {:
                
                                                                                                :}
|           FALSE                                                                                    {:
                
                                                                                                :}
|           LPAREN exp RPAREN                                                                                   {:
                
                                                                                                :}
|           fncall                                                                                  {:
                
                                                                                                :};

fncall                                                                                                   ::=  
            id LPAREN RPAREN                                                                                 {:
                    // fn call with no args
                                                                                                        :}
|           id LPAREN actualList RPAREN                                                                    {:
                    // with args
                                                                                                        :};

actualList                                                                                               ::= 
            exp                                                                                          {:

                                                                                                         :}
|           actualList COMMA exp                                                                          {:
                
                                                                                                        :};

type                                                                                                     ::= 
            INT                                                                                          {: 
                RESULT = new IntNode();
                                                                                                         :}
|           BOOL                                                                                           {:
                RESULT = new BoolNode();
                                                                                                           :}
|           VOID                                                                                           {:
                RESULT = new VoidNode();
                                                                                                        :};

loc                                                                                                      ::= 
            id                                                                                              {:
                                                                                    
                                                                                                            :}
|           loc DOT id                                                                                       {:
                                                                                                    
                                                                                                            :};

id                                                                                                        ::= 
            ID:i                                                                                           {: 
                RESULT = new IdNode(i.linenum, i.charnum, i.idVal);
                                                                                                            :};

/* 2. TODO: Add grammar rules: 
Building an Abstract-Syntax Tree
To make your parser build an abstract-syntax tree, you must add new productions, declarations, and actions. You will need to decide, for each nonterminal that you add, what type its associated value should have. Then you must add the appropriate nonterminal declaration to the specification. For most nonterminals, the value will either be some kind of tree node (a subclass of ASTnode) or a LinkedList of some kind of node (use the information in ast.java to guide your decision). Note that you cannot use parameterized types for the types of nonterminals; so if the translation of a nonterminal is a LinkedList of some kind of node, you will have to declare its type as just plain LinkedList.

You must also add actions to each new grammar production that you add to cminusminus.cup. Make sure that each action ends by assigning an appropriate value to RESULT. Note that the parser will return a Symbol whose value field contains the value assigned to RESULT in the production for the root nonterminal (nonterminal program).

*/