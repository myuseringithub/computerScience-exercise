// use the Linux utility diff to compare your file of error messages with the one supplied for this example

bool bbb;
struct S { int a; };
struct S t;

void f(int p1, bool p2) {
}

void main() {
    int aaa;

    // some errors involving illegal operations on functions
    aaa = f + f;
    bbb = f == 3;
    bbb = f > main;
    bbb = f == f;

    // some errors involving bad function calls 
    aaa();
    f();
    f(5);
    f(aaa, aaa);
    f(t, t.a);
    S();

    // some errors involving structs 
    t = 5;
    t = t;
    cin >> S;
    t = true || 3;
    bbb = S && t.a;

    // error involving return
    return 10;

    // other type errors 
    aaa = aaa + (!false);
    aaa = aaa + "foo";
    bbb = aaa;

    // don't give too many or too few error messages here 
    bbb = (aaa + true) && (bbb < true);
}












/******************************************************************************/
// TODO:
// typeErrors.cminusminus should contain code with errors detected by the type checker. For every type error listed in the table above, you should include an instance of that error for each of the relevant operators, and in each part of a program where the error can occur (e.g., in a top-level statement, in a statement inside a while loop, etc).

// should output error messages to be output.







// Check for assignment expression if lhs & rhs both are void function.















// EXAMPLE for cascading errors corret handling:

struct P { int x; bool y; }; 
struct P p; 
bool f(int x) { 
    return false; 
}

// Each of the following should cause only one error message:
void t(int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11 ) {
    // the type given to (true + 3) should be ErrorType, and the type-check method for the multiplication node should not report "Arithmetic operator applied to non-numeric operand" for the first operand.
    f++;
}




(true + 3) * 4         // true + 3 is an error; the * is OK

cout << P + 1          // P + 1 is an error; the write is OK

true && (false || 3)   // false || 3 is an error; the && is OK

f("a" * 4);            // "a" * 4 is an error; the call is OK

1 + p();               // p() is an error; the + is OK

(true + 3) == x        // true + 3 is an error; the == is OK
                       // regardless of the type of x


// Each should cause two error messages:

true + "hello"    // one error for each of the non-int operands of the +

1 + f(true)       // one for the bad arg type and one for the 2nd operand of the +

1 + f(1, 2)       // one for the wrong number of args and one for the 2nd operand of the +

return 3+true;    // in a void function: one error for the 2nd operand to +
                  // and one for returning a value

